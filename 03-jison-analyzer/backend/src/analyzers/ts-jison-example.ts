import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType } from '@ts-jison/parser';
/**
 * parser generated by  @ts-jison/parser-generator 0.4.1-alpha.2
 * @returns Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */

  import LexicalError from './Exceptions/Lexical.js';

  import SyntaxError from './Exceptions/Syntax.js'
  import BinaryExpr from './Expressions/Binary.js'
  import LiteralExpr from './Expressions/Literal.js'
  import UnaryExpr from './Expressions/Unary.js'
  import EchoStmt from './Statements/Echo.js'
  import VarDeclarationStmt from './Statements/VarDeclaration.js'
  import VarAssignmentStmt from './Statements/VarAssignment.js'
  import VarLookUpExpr from './Expressions/VarLookUp.js'
  import BlockStmt from './Statements/Block.js'
  const errors = []

export class TsJisonExampleParser extends JisonParser implements JisonParserApi {
    $?: any;
    symbols_: SymbolsType = {"error":2,"start":3,"statements":4,"EOF":5,"statement":6,";":7,"ECHO":8,"expression":9,"var_declaration":10,"var_assignment":11,"block":12,"{":13,"}":14,"LET":15,"IDENTIFIER":16,":":17,"type":18,"=":19,"expressions":20,"arithmetic":21,"relational":22,"(":23,")":24,"-":25,"literal":26,"+":27,"==":28,"INT_LITERAL":29,"STRING_LITERAL":30,"NULL":31,"INT":32,"STRING":33,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",5:"EOF",7:";",8:"ECHO",13:"{",14:"}",15:"LET",16:"IDENTIFIER",17:":",19:"=",23:"(",24:")",25:"-",27:"+",28:"==",29:"INT_LITERAL",30:"STRING_LITERAL",31:"NULL",32:"INT",33:"STRING"};
    productions_: ProductionsType = [0,[3,2],[4,3],[4,2],[4,2],[6,2],[6,1],[6,1],[6,1],[12,3],[10,6],[10,4],[11,3],[20,2],[20,1],[9,1],[9,1],[9,3],[9,3],[9,2],[9,1],[9,1],[21,3],[21,3],[22,3],[26,1],[26,1],[26,1],[18,1],[18,1],[18,1]];
    table: Array<StateType>;
    defaultActions: {[key:number]: any} = {6:[2,6],7:[2,7],8:[2,8],12:[2,1],38:[2,9]};

    constructor (yy = {}, lexer = new TsJisonExampleLexer(yy)) {
      super(yy, lexer);

      // shorten static method to just `o` for terse STATE_TABLE
      const $V0=[1,4],$V1=[1,5],$V2=[1,11],$V3=[1,9],$V4=[1,10],$V5=[1,22],$V6=[1,19],$V7=[1,20],$V8=[1,23],$V9=[1,24],$Va=[1,25],$Vb=[5,8,13,14,15,16],$Vc=[1,31],$Vd=[1,30],$Ve=[1,32],$Vf=[7,24,25,27,28],$Vg=[7,19];
      const o = JisonParser.expandParseTable;
      this.table = [{2:$V0,3:1,4:2,6:3,8:$V1,10:6,11:7,12:8,13:$V2,15:$V3,16:$V4},{1:[3]},{5:[1,12],6:13,8:$V1,10:6,11:7,12:8,13:$V2,15:$V3,16:$V4},{7:[1,14]},{7:[1,15]},{9:16,16:$V5,21:17,22:18,23:$V6,25:$V7,26:21,29:$V8,30:$V9,31:$Va},{7:[2,6]},{7:[2,7]},{7:[2,8]},{16:[1,26]},{19:[1,27]},{2:$V0,4:28,6:3,8:$V1,10:6,11:7,12:8,13:$V2,15:$V3,16:$V4},{1:[2,1]},{7:[1,29]},o($Vb,[2,3]),o($Vb,[2,4]),{7:[2,5],25:$Vc,27:$Vd,28:$Ve},o($Vf,[2,15]),o($Vf,[2,16]),{2:[1,34],9:33,16:$V5,21:17,22:18,23:$V6,25:$V7,26:21,29:$V8,30:$V9,31:$Va},{9:35,16:$V5,21:17,22:18,23:$V6,25:$V7,26:21,29:$V8,30:$V9,31:$Va},o($Vf,[2,20]),o($Vf,[2,21]),o($Vf,[2,25]),o($Vf,[2,26]),o($Vf,[2,27]),{17:[1,36]},{9:37,16:$V5,21:17,22:18,23:$V6,25:$V7,26:21,29:$V8,30:$V9,31:$Va},{6:13,8:$V1,10:6,11:7,12:8,13:$V2,14:[1,38],15:$V3,16:$V4},o($Vb,[2,2]),{9:39,16:$V5,21:17,22:18,23:$V6,25:$V7,26:21,29:$V8,30:$V9,31:$Va},{9:40,16:$V5,21:17,22:18,23:$V6,25:$V7,26:21,29:$V8,30:$V9,31:$Va},{9:41,16:$V5,21:17,22:18,23:$V6,25:$V7,26:21,29:$V8,30:$V9,31:$Va},{24:[1,42],25:$Vc,27:$Vd,28:$Ve},{24:[1,43]},o($Vf,[2,19]),{18:44,31:[1,47],32:[1,45],33:[1,46]},{7:[2,12],25:$Vc,27:$Vd,28:$Ve},{7:[2,9]},o($Vf,[2,22]),o($Vf,[2,23]),o([7,24,28],[2,24],{25:$Vc,27:$Vd}),o($Vf,[2,17]),o($Vf,[2,18]),{7:[2,11],19:[1,48]},o($Vg,[2,28]),o($Vg,[2,29]),o($Vg,[2,30]),{9:49,16:$V5,21:17,22:18,23:$V6,25:$V7,26:21,29:$V8,30:$V9,31:$Va},{7:[2,10],25:$Vc,27:$Vd,28:$Ve}];
    }

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1:
 return {errors: errors, ast: $$[$0-1]} 
break;
case 2:

    $$[$0-2].push($$[$0-1])
    this.$ = $$[$0-2]
  
break;
case 3:
 this.$ = [$$[$0-1]] 
break;
case 4:

    errors.push(new SyntaxError($$[$0-1], _$[$0-1]))
    this.$ = []
  
break;
case 5:
 this.$ = new EchoStmt($$[$0], _$[$0-1]) 
break;
case 9:
 this.$ = new BlockStmt($$[$0-1], _$[$0-2])
break;
case 10:
 this.$ = new VarDeclarationStmt($$[$0-4], $$[$0-2], $$[$0], _$[$0-4]) 
break;
case 11:
 this.$ = new VarDeclarationStmt($$[$0-2], $$[$0], null, _$[$0-2]) 
break;
case 12:
 this.$ = new VarAssignmentStmt($$[$0-2], $$[$0], _$[$0-2]) 
break;
case 13:

    $$[$0-1].push($$[$0])
    this.$ = $$[$0-1]
  
break;
case 14:
this.$ = [$$[$0]]
break;
case 17:
 this.$ = $$[$0-1] 
break;
case 18:

    errors.push(new SyntaxError(_$[$0-1], _$[$0-1]))
  
break;
case 19:
 this.$ = new UnaryExpr($$[$0-1], $$[$0], _$[$0-1]) 
break;
case 21:
 this.$ = new VarLookUpExpr($$[$0], _$[$0]) 
break;
case 22: case 23:
this.$ = new BinaryExpr($$[$0-2], $$[$0-1], $$[$0], _$[$0-1]) 
break;
case 24:
 this.$ = new BinaryExpr($$[$0-2], $$[$0-1], $$[$0], _$[$0-2]) 
break;
case 25:
 this.$ = new LiteralExpr($$[$0], 'INT', _$[$0]) 
break;
case 26:
 this.$ = new LiteralExpr($$[$0], 'STRING', _$[$0]) 
break;
case 27:
 this.$ = new LiteralExpr($$[$0], 'NULL', _$[$0]) 
break;
        }
    }
}


/* generated by @ts-jison/lexer-generator 0.4.1-alpha.2 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';

export class TsJisonExampleLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"case_insensitive":true,"moduleName":"TsJisonExample"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [
        /^(?:\s+)/,
        /^(?:[0-9]+)/,
        /^(?:"[^"]*")/,
        /^(?:;)/,
        /^(?::)/,
        /^(?:-)/,
        /^(?:\+)/,
        /^(?:==)/,
        /^(?:=)/,
        /^(?:\()/,
        /^(?:\))/,
        /^(?:\{)/,
        /^(?:\})/,
        /^(?:echo\b)/,
        /^(?:let\b)/,
        /^(?:int\b)/,
        /^(?:string\b)/,
        /^(?:null\b)/,
        /^(?:[a-z][a-z0-9]*)/,
        /^(?:$)/,
        /^(?:.)/
    ];
    conditions: any = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:/* skip whitespace */
      break;
    case 1:return 29
      break;
    case 2:return 30
      break;
    case 3:return 7
      break;
    case 4:return 17
      break;
    case 5:return 25
      break;
    case 6:return 27
      break;
    case 7:return 28
      break;
    case 8:return 19
      break;
    case 9:return 23
      break;
    case 10:return 24
      break;
    case 11:return 13
      break;
    case 12:return 14
      break;
    case 13:return 8
      break;
    case 14:return 15
      break;
    case 15:return 32
      break;
    case 16:return 33
      break;
    case 17:return 31
      break;
    case 18:return 16
      break;
    case 19:return 5
      break;
    case 20:
  throw new LexicalError(yy_.yytext, yy_.yylineno + 1, yy_.yylloc.first_column + 1);

      break;
        }
    }
}


